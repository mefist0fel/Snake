<html>
	<head>
		<title>Snake 3d game</title>
		<style type="text/css">
		body {
			display: block;
			background-color:0;
			width: 100%;
			height: 100%;
			margin: 0;
		}
		canvas {
			background-color:#000000;
			display: block;
			margin: 0px auto;
		}
		</style>
	</head>
	<body>
		<canvas id="snake"></canvas>
	</body>
	<script type="text/javascript" src="geometry.js"></script>
	<script type="text/javascript" src="input.js"></script>
	<script type="text/javascript" src="camera.js"></script>
	<script type="text/javascript" src="object3d.js"></script>
	<script type="text/javascript" src="level.js"></script>
	<script type="text/javascript" src="navigation_mesh.js"></script>
	<script type="text/javascript" src="navigation_node.js"></script>
	<script type="text/javascript" src="apple.js"></script>
	<script type="text/javascript" src="snake.js"></script>
	<!--
	<script type="text/javascript" src="jsfxr.js"></script>
	<script type="text/javascript" src="audio.js"></script>-->
	<script type="text/javascript">
	const minDt = 1/30
	let fps,
		time = timestamp()

	let width = document.documentElement.clientWidth
	let height = document.documentElement.clientHeight
	let minSize = Math.min(width, height)
	const selectLevelState = 0
	const pauseState = 1
	const gameState = 2
	let state = selectLevelState
	
	// init
	let input = Input()
	let canvasElement = document.getElementById('snake')
	let canvas = canvasElement.getContext('2d')
	let camera = new Camera(canvas)
	SetCanvasSize(width, height)

	let applesCount = 1

	let currentMatrix = CreateUnitMatrix3()
	let rotationAxe = NormalizeVector3(CreateVector3(1.0, 1.0, 1.0))

	let level = new Level()

	createSphere()// createDrawedCube()

	let navigationTriangles = CreateNavigationSphere() // CreateNavigationCube(11.0)
	let navigationNodes = []
	for(let i = 0; i < navigationTriangles.length; i++) {
		let points = navigationTriangles[i]
		navigationNodes.push(
			new NavigationNode(
				points[0],
				points[1],
				points[2]
			)
		)
	}

	let navigationMesh = new NavigationMesh(navigationNodes)
	let apples = [
		new Apple(navigationMesh.getRandomPosition()),
		new Apple(navigationMesh.getRandomPosition()),
		new Apple(navigationMesh.getRandomPosition())
	]
	let snake = new Snake(navigationMesh)
	snake.setEnabled(false)

	let navigationObjects = null
	let needShowDebugInfo = false
	let needShowFPSInfo = false

	ShowDebugInfo(needShowDebugInfo)

	function timestamp() {
		return window.performance && window.performance.now ? window.performance.now() : new Date().getTime()
	}

	function render() {
		// clear
		canvas.fillStyle = '#000011'
		canvas.font = "16pt Arial"
		canvas.fillRect ( 0, 0, width, height)
		switch(state) {
			default:
			case selectLevelState:
				renderSelectLevelState()
				break
			case pauseState:
				renderPauseState()
				break
			case gameState:
				renderGameState()
				break
		}
		// debug
		if (needShowFPSInfo) {
			canvas.fillText("FPS:", width - 120, 50)
			canvas.textAlign = "end";
			canvas.fillText(parseInt(fps), width - 30, 50)
		}
	}

	function renderSelectLevelState() {
		camera.render()
		// info
		canvas.fillStyle = '#FFFFFF'
		canvas.textAlign = "center"; // "start", "end", "center", "left", "right"
		canvas.fillText("space to start: ", width * 0.5, 50)
	}

	function renderPauseState() {
		camera.render()
		// info
		canvas.fillStyle = '#FFFFFF'  // white
		canvas.textAlign = "center"; // "start", "end", "center", "left", "right"
		canvas.fillText("PAUSE ", width * 0.5, height * 0.5 - minSize * 0.4)
		canvas.fillText("Q to quit ", width * 0.5, height * 0.5 + minSize * 0.4)
		canvas.fillText("Esc to continue ", width * 0.5, height * 0.5 + minSize * 0.45)
	}

	function renderGameState() {
		camera.render()
		// info
		canvas.fillStyle = '#FFFFFF'  // white
		canvas.textAlign = "start"; // "end", "center", "left", "right"
		canvas.fillText("Apples: " + applesCount, 30, 50)
	}

	function update(dt) {
		switch(state) {
			default:
			case selectLevelState:
				updateSelectLevelState(dt)
				break
			case pauseState:
				updatePauseState(dt)
				break
			case gameState:
				updateGameState(dt)
				break
		}
		if (input.key[115]) { // F4
			input.key[115] = false
			needShowFPSInfo = !needShowFPSInfo
		}
	}

	function updateSelectLevelState(dt) {
		if (input.key[32]) { // space
			setState(gameState)
		}
		currentMatrix = MultiplyMatrix3(currentMatrix, CreateRotationMatrix3(rotationAxe, 20.0 * dt))
		rotationAxe = NormalizeVector3(
			CreateVector3(
				rotationAxe[0] * 100.0 + (Math.random() * 2.0 - 1),
				rotationAxe[1] * 100.0 + (Math.random() * 2.0 - 1),
				rotationAxe[2] * 100.0 + (Math.random() * 2.0 - 1)))
		camera.worldMatrix = currentMatrix
		camera.position = MultiplyVector3(camera.position, 1.0 - 1.0 * dt)
	}

	function updatePauseState(dt) {
		if (input.key[27]) { // esc
			input.key[27] = false
			setState(gameState)
		}
		if (input.key[81]) { // Q
			input.key[81] = false
			setState(selectLevelState)
		}
	}

	function updateGameState(dt) {
		// control
		// UP = 38
		// DOWN = 40
		// LEFT = 37
		// RIGHT = 39
		// W = 87
		// S = 83
		// A = 65
		// D = 68
		// space = 32
		if (input.key[27]) { // esc
			input.key[27] = false
			setState(pauseState)
		}
		let rotateAngle = 0
		if (input.key[65] || input.key[37]) { // LEFT | A
			rotateAngle = 1.0
		}
		if (input.key[68] || input.key[39]) { // RIGHT | D
			rotateAngle = -1.0
		}
		if (input.mouseLeft) {
			if (inRect(input.mousePosition[0], input.mousePosition[1], 0.0, height * 0.5, width * 0.3, height * 1.0)) {
				rotateAngle = 1.0 // left
			}
			if (inRect(input.mousePosition[0], input.mousePosition[1], width * 0.7, height * 0.5, width * 1.0, height * 1.0)) {
				rotateAngle = -1.0 // right
			}
		}
		snake.rotate(rotateAngle)


		snake.update(dt)
		for(let i = 0; i < apples.length; i++) {
			apples[i].update(dt)
			if (DistanceVector3(navigationMesh.heroPosition, apples[i].position) < 1.0) {
				apples[i].removeApple(navigationMesh.getRandomPosition())
        		snake.lenght += 0.5
				applesCount += 1
			}
		}

		camera.position = snake.position

		let cameraVector = NormalizeVector3(snake.position)
		let XZVector = NormalizeVector2([cameraVector[0], cameraVector[2]])
		let YNVector = NormalizeVector2([cameraVector[1], Math.sqrt(cameraVector[0], cameraVector[2])])
		let baseAngle = Math.acos(XZVector[0]) / Math.PI * 180.0
		let upAngle = Math.acos(cameraVector[1]) / Math.PI * 180.0 - 90.0
		if (cameraVector[2] > 0) {
		 	baseAngle += 90.0
		} else {
		 	baseAngle = 90.0 - baseAngle
		}
		camera.worldMatrix = MultiplyMatrix3(CreateRotationMatrix3(CreateVector3(1.0), upAngle), CreateRotationMatrix3(CreateVector3(0.0, 1.0), baseAngle))
		if (input.key[32]) { // space
		}
		if (input.key[113]) { // F2
			input.key[113] = false
			needShowDebugInfo = !needShowDebugInfo
			ShowDebugInfo(needShowDebugInfo)
		}
	}
	
	function setState(newState) {
		state = newState
		switch(state) {
			default:
			case selectLevelState:
				currentMatrix = camera.worldMatrix
				snake.setEnabled(false)
				break
			case pauseState:
				break
			case gameState:
				snake.setEnabled(true)
				break
		}
	}
	
	function ShowDebugInfo(needShow) {
		if (navigationObjects == null) {
			navigationObjects = []
			for(let i = 0; i < navigationNodes.length; i++) {
				let navigationTriangle = 
					new Object3DTriangle(
						navigationNodes[i].pointA,
						navigationNodes[i].pointB,
						navigationNodes[i].pointC,
						"rgb(255,255,255)", false, false
					)
				navigationObjects.push(navigationTriangle)
			}
			navigationObjects.push(new Object3D(CreateVector3(8.0, 0.0, 0.0), 0.5, rgbToHex(255, 0, 0)))
			navigationObjects.push(new Object3D(CreateVector3(0.0, 8.0, 0.0), 0.5, rgbToHex(0, 255, 0)))
			navigationObjects.push(new Object3D(CreateVector3(0.0, 0.0, 8.0), 0.5, rgbToHex(0, 0, 255)))
		}
		for(let i = 0; i < navigationObjects.length; i++) {
			navigationObjects[i].enabled = needShow;
		}
	}

	function frame() {
		let now = timestamp()
		let delta = (now - time) / 1000.0
		fps = 1.0 / delta
		if (delta > minDt) {
			delta = minDt
		}
		update(delta)
		render()
		time = now
		requestAnimationFrame(frame)
		if (width != document.documentElement.clientWidth || height != document.documentElement.clientHeight) {
			width = document.documentElement.clientWidth
			height = document.documentElement.clientHeight
			minSize = Math.min(width, height)
			SetCanvasSize(width, height)
		}
	}
	requestAnimationFrame(frame)

	function SetCanvasSize(width, height) {
		canvasElement.width = width
		canvasElement.height = height
		camera.setSize(width, height)
	}

	</script>
</html>