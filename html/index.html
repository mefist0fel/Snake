<html>
	<head>
		<title>Snake 3d game</title>
		<style type="text/css">
		body {
			display: block;
			background-color:0;
			width: 100%;
			height: 100%;
			margin: 0;
		}
		canvas {
			background-color:#ffffff;
			display: block;
			margin: 0px auto;
		}
		</style>
	</head>
	<body>
		<canvas id="snake"></canvas>
	</body>
	<script type="text/javascript" src="geometry.js"></script>
	<script type="text/javascript" src="input.js"></script>
	<script type="text/javascript" src="camera.js"></script>
	<script type="text/javascript" src="object3d.js"></script>
	<script type="text/javascript" src="level.js"></script>
	<script type="text/javascript" src="navigation_mesh.js"></script>
	<script type="text/javascript" src="navigation_node.js"></script>
	<script type="text/javascript" src="apple.js"></script>
	<!--
	<script type="text/javascript" src="jsfxr.js"></script>
	<script type="text/javascript" src="audio.js"></script>-->
	<script type="text/javascript">
	let now,
		dt = 0,
		time = timestamp(),
		step = 1/30,
		width = 1024,
		height = 768

	width = document.documentElement.clientWidth
	height = document.documentElement.clientHeight
	let x = 0.0 // 180 + 45.0
	let y = 0.0 // -45.0 + 22.5
	let applesCount = 1
	let upVector = CreateVector3(0, 1)
	let rightVector = CreateVector3(1, 0)

	let currentMatrix = CreateUnitMatrix3()
	let defaultCameraDirection = CreateVector3(0.0, 0.0, -1.0)

	let camera = new Camera(width, height)

	let objects = createSphere()// createDrawedCube()

	let navigationTriangles = CreateNavigationSphere() // CreateNavigationCube(11.0)
	let navigationNodes = []
	for(let i = 0; i < navigationTriangles.length; i++) {
		let points = navigationTriangles[i]
		navigationNodes.push(
			new NavigationNode(
				points[0],
				points[1],
				points[2]
			)
		)
	}

	let navigationMesh = new NavigationMesh(navigationNodes)
	let apples = [
		new Apple(navigationMesh.getRandomPosition()),
		new Apple(navigationMesh.getRandomPosition()),
		new Apple(navigationMesh.getRandomPosition())
	]

	for(let i = 0; i < apples.length; i++) {
		objects.push(apples[i].object3d)
	}

	let navigationObjects = null
	let debugButtonPressed = false
	let needShowDebugInfo = false

	ShowDebugInfo(needShowDebugInfo)
	let heroView = new Object3D(navigationMesh.heroPosition, 0.5, rgbToHex(60, 128, 60))
	let currentCameraDirection = navigationMesh.heroNormal
	objects.push(heroView)
	let targetView = new Object3D(AddVector3(navigationMesh.heroPosition, navigationMesh.heroVector), 0.2, rgbToHex(0, 0, 255))
	objects.push(targetView)
	// objects.push(new Object3D(CreateVector3(8.0, 0.0, 0.0), 0.5, rgbToHex(255, 0, 0)))
	// objects.push(new Object3D(CreateVector3(0.0, 8.0, 0.0), 0.5, rgbToHex(0, 255, 0)))
	// objects.push(new Object3D(CreateVector3(0.0, 0.0, 8.0), 0.5, rgbToHex(0, 0, 255)))

	// init
	let canvasElement = document.getElementById('snake')
	let canvas = canvasElement.getContext('2d')
	canvasElement.width = width
	canvasElement.height = height
	rect = canvasElement.getBoundingClientRect()

	let input = Input(rect, canvasElement)

	function timestamp() {
		return window.performance && window.performance.now ? window.performance.now() : new Date().getTime()
	}

	function render() {
		// clear
		canvas.fillStyle = '#000011'
		canvas.fillRect ( 0, 0, width, height)

		// canvas.fillStyle = '#FFEEEE'
		camera.prepareScene()
		for (let i = 0; i < objects.length; i++) {
			objects[i].prepareScene(camera)
		}
		objects.sort(object3DDepthComparator)
		for (let i = 0; i < objects.length; i++) {
			objects[i].draw(canvas)
		}

		// help
		canvas.fillStyle    = '#FFFFFF'  // white
		canvas.font = "14pt Arial"
		canvas.fillText("Apples " + applesCount, 30, 30)
		// canvas.fillText("Z / X - change height constant", 10, 50)
		// canvas.fillText("C / V - change tile aspect", 10, 70)
		// canvas.fillText("Camera angle " + camera.angle, 10, 90)
	}

	function update(dt) {
		for(let i = 0; i < apples.length; i++) {
			apples[i].update(dt)
			if (DistanceVector3(navigationMesh.heroPosition, apples[i].position) < 1.0) {
				apples[i].removeApple(navigationMesh.getRandomPosition())
				applesCount += 1
			}
		}

		// control
		// UP = 38
		// DOWN = 40
		// LEFT = 37
		// RIGHT = 39
		// W = 87
		// S = 83
		// A = 65
		// D = 68
		// space = 32
		let moveSpeed = 3.0 * dt
		let rotateSpeed = 60.0 * dt
		navigationMesh.moveHero(moveSpeed)
		// if (input.key[87] || input.key[38]) { // UP | W
		// 	navigationMesh.moveHero(moveSpeed)
		// }
		// if (input.key[83] || input.key[40]) { // DOWN | S
		// 	navigationMesh.moveHero(-moveSpeed)
		// }
		if (input.key[65] || input.key[37]) { // LEFT | A
			navigationMesh.rotateHeroDirection(rotateSpeed)
		}
		if (input.key[68] || input.key[39]) { // RIGHT | D
			navigationMesh.rotateHeroDirection(-rotateSpeed)
		}
		heroView.position = navigationMesh.heroPosition
		targetView.position = AddVector3(navigationMesh.heroPosition, navigationMesh.heroVector)
		camera.position = SubstractVector3(CreateVector3(0.0, 0.0, 0.0), heroView.position)

		let cameraVector = NormalizeVector3(heroView.position)
		let XZVector = NormalizeVector2([cameraVector[0], cameraVector[2]])
		let YNVector = NormalizeVector2([cameraVector[1], Math.sqrt(cameraVector[0], cameraVector[2])])
		let baseAngle = Math.acos(XZVector[0]) / Math.PI * 180.0
		let upAngle = Math.acos(cameraVector[1]) / Math.PI * 180.0 - 90.0
		if (cameraVector[2] > 0) {
		 	baseAngle += 90.0
		} else {
		 	baseAngle = 90.0 - baseAngle
		}
		camera.worldMatrix = MultiplyMatrix3(CreateRotationMatrix3(CreateVector3(1.0), upAngle), CreateRotationMatrix3(CreateVector3(0.0, 1.0), baseAngle))
		if (input.key[32]) { // space
		}
		if (input.key[113]) { // F2
			if (!debugButtonPressed) {
				debugButtonPressed = true
				needShowDebugInfo = !needShowDebugInfo
				ShowDebugInfo(needShowDebugInfo)
			}
		} else {
			debugButtonPressed = false
		}
	}
	
	function ShowDebugInfo(needShow) {
		if (navigationObjects == null) {
			navigationObjects = []
			for(let i = 0; i < navigationNodes.length; i++) {
				let navigationTriangle = 
					new Object3DTriangle(
						navigationNodes[i].pointA,
						navigationNodes[i].pointB,
						navigationNodes[i].pointC,
						"rgb(255,255,255)", false, false
					)
				objects.push(navigationTriangle)
				navigationObjects.push(navigationTriangle)
			}
		}
		for(let i = 0; i < navigationObjects.length; i++) {
			navigationObjects[i].enabled = needShow;
		}
	}

	function frame() {
		now = timestamp()
		dt = dt + Math.min(1, (now - time) / 1000)
		if (dt > step) {
			dt = step
		}
		update(dt)
		render()
		time = now
		requestAnimationFrame(frame)
	}
	requestAnimationFrame(frame)

	</script>
</html>